ØªÙ…Ø§Ù… â€” Ø¹Ù†Ø¯Ùƒ â€œBatchingâ€ Ø¨Ø§Ù„Ø§Ø³Ù… ÙÙ‚Ø·ØŒ Ù„ÙƒÙ† ÙØ¹Ù„ÙŠÙ‹Ø§ Ø£Ù†Øª Ù…Ø§ Ø²Ù„Øª ØªØ¹Ù…Ù„ Ø£Ø³ÙˆØ£ 3 Ø£Ø´ÙŠØ§Ø¡:

ØªØ±Ø¬Ø¹ Base64 Ù…Ù† captureFrameData

ØªØ®Ø²Ù† Base64 ÙÙŠ batchFrames (Ù‡Ø°Ø§ ÙˆØ­Ø¯Ù‡ ÙŠÙ‚ØªÙ„ Ø§Ù„Ø°Ø§ÙƒØ±Ø©)

ØªÙƒØªØ¨ ÙƒÙ„ Ø§Ù„Ø¥Ø·Ø§Ø±Ø§Øª Ù„ÙƒÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù‚Ø¨Ù„ Ù…Ø§ ØªØ´ÙÙ‘Ø± (ÙˆÙ„Ø§ ÙÙŠÙ‡ concat ÙˆÙ„Ø§ Ø­Ø°Ù)

Ø®Ù„Ù‘ÙŠÙ†Ø§ Ù†Ø¹Ø¯Ù‘Ù„ Ø¨Ø£Ù‚Ù„ ØªØºÙŠÙŠØ± Ù…Ù…ÙƒÙ† Ù…Ø¹ Ø£Ø¹Ù„Ù‰ Ø£Ø«Ø±:

A) Ø¹Ø¯Ù‘Ù„ captureFrameData Ù„ÙŠÙØ±Ø¬Ù‘Ø¹ Bytes Ù…Ø¨Ø§Ø´Ø±Ø© (Ø¨Ø¯ÙˆÙ† Base64 ÙˆØ¨Ø¯ÙˆÙ† batchFrames)

Ø¨Ø¯Ù„ return canvas.toDataURL(...) Ø®Ù„ÙŠÙ‡ ÙŠØ·Ù„Ø¹ Uint8Array:

async captureFrameBytes(previewElement, canvas, ctx, width, height, frameIndex) {
  const html2canvas = window.html2canvas;

  let targetElement;
  if (previewElement.tagName === 'IFRAME') {
    const iframeDoc = previewElement.contentDocument;
    targetElement = this.getCaptureTarget(iframeDoc);

    if (frameIndex === 0) {
      this.lockTargetSize(targetElement, width, height);
    }
  } else {
    targetElement = previewElement;
  }

  const captureCanvas = await html2canvas(targetElement, {
    width,
    height,
    scale: 1,
    useCORS: true,
    allowTaint: false,
    backgroundColor: null,
    logging: false,
    imageTimeout: 0
  });

  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(captureCanvas, 0, 0, width, height);

  // ğŸ”¥ Ø¨Ø¯ÙŠÙ„ Base64: PNG bytes Ù…Ø¨Ø§Ø´Ø±Ø©
  const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
  const buf = await blob.arrayBuffer();
  return new Uint8Array(buf);
}


Ù†Ù‚Ø·Ø© Ù…Ù‡Ù…Ø©: Ø§Ù„Ø¢Ù† Ù…Ø§ ÙÙŠÙ‡ atob ÙˆÙ„Ø§ split(',') ÙˆÙ„Ø§ ØªØ®Ø²ÙŠÙ† Base64.

B) Ù„Ø§ ØªØ®Ø²Ù† Ø§Ù„Ø¯ÙØ¹Ø© ÙÙŠ batchFrames Ø£Ø³Ø§Ø³Ù‹Ø§

Ø§ÙƒØªØ¨ ÙƒÙ„ Ø¥Ø·Ø§Ø± Ù„Ù„Ù€ FS Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ‚Ø§Ø·Ù‡ (Ù‡Ø°Ø§ ÙŠÙ‚Ù„Ù„ peak memory ÙƒØ«ÙŠØ±):

function pad5(n) { return String(n).padStart(5, '0'); }

function safeUnlink(ffmpeg, path) {
  try { ffmpeg.FS('unlink', path); } catch {}
}


Ø¯Ø§Ø®Ù„ Ø­Ù„Ù‚Ø© Ø§Ù„Ø§Ù„ØªÙ‚Ø§Ø·:

const framesPerPart = fps * 4; // 4 Ø«ÙˆØ§Ù†ÙŠ Ù„ÙƒÙ„ part (Ø¹Ø¯Ù„Ù‡Ø§)
const partCount = Math.ceil(totalFrames / framesPerPart);
const partFiles = [];

for (let part = 0; part < partCount; part++) {
  const start = part * framesPerPart;
  const end = Math.min(start + framesPerPart, totalFrames);
  const framesInPart = end - start;

  // 1) Ø§ÙƒØªØ¨ Frames Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø¯ÙØ¹Ø© (ØªØ¨Ø¯Ø£ Ù…Ù† 1 Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¯ÙØ¹Ø©)
  for (let local = 0; local < framesInPart; local++) {
    const i = start + local;
    const currentTime = i / fps;

    this.seekAnimationsToTime(iframeDoc, currentTime);

    const bytes = await this.captureFrameBytes(previewElement, canvas, ctx, width, height, i);
    const fileName = `frame_${pad5(local + 1)}.png`;

    this.ffmpeg.FS('writeFile', fileName, bytes);
  }

  // 2) Ø´ÙÙ‘Ø± Ø§Ù„Ø¯ÙØ¹Ø© Ø¥Ù„Ù‰ part.mp4
  const partName = `part_${pad5(part + 1)}.mp4`;
  await this.ffmpeg.run(
    '-framerate', String(fps),
    '-i', 'frame_%05d.png',
    '-c:v', 'libx264',
    '-pix_fmt', 'yuv420p',
    '-crf', String(crf),
    '-preset', 'veryfast',
    '-tune', 'animation',
    '-movflags', '+faststart',
    partName
  );
  partFiles.push(partName);

  // 3) Ø§Ø­Ø°Ù PNGs Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ´ÙÙŠØ±
  for (let k = 1; k <= framesInPart; k++) {
    safeUnlink(this.ffmpeg, `frame_${pad5(k)}.png`);
  }
}


Ù„Ø§Ø­Ø¸: Ø£Ù†Øª ÙƒÙ†Øª ØªØ³ØªØ®Ø¯Ù… frame%05d.pngØŒ Ø£Ù†Ø§ Ø¬Ø¹Ù„ØªÙ‡Ø§ frame_%05d.png Ù„ØªÙƒÙˆÙ† ÙˆØ§Ø¶Ø­Ø©.

C) concat Ù†Ù‡Ø§Ø¦ÙŠ Ø¨Ø¯ÙˆÙ† Ø¥Ø¹Ø§Ø¯Ø© ØªØ±Ù…ÙŠØ²

Ø¨Ø¹Ø¯ Ù…Ø§ ØªØ®Ù„Øµ ÙƒÙ„ parts:

const list = partFiles.map(p => `file '${p}'`).join('\n');
this.ffmpeg.FS('writeFile', 'list.txt', new TextEncoder().encode(list));

await this.ffmpeg.run(
  '-f', 'concat',
  '-safe', '0',
  '-i', 'list.txt',
  '-c', 'copy',
  outputFile
);

// cleanup
safeUnlink(this.ffmpeg, 'list.txt');
for (const p of partFiles) safeUnlink(this.ffmpeg, p);

D) ØªØºÙŠÙŠØ±Ø§Øª â€œØµØºÙŠØ±Ø©â€ Ù„ÙƒÙ†Ù‡Ø§ Ù‚Ø§ØªÙ„Ø© Ù„Ù„Ø£Ø®Ø·Ø§Ø¡
1) Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… batchSize = 30 ÙƒÙ…Ø¹Ù†Ù‰ batching

30 Ø¥Ø·Ø§Ø± Ø¹Ù†Ø¯ 30fps = Ø«Ø§Ù†ÙŠØ© ÙˆØ§Ø­Ø¯Ø© = Ù…Ø§ ÙŠÙ‚Ù„Ù„ Ø´ÙŠØ¡ ØªÙ‚Ø±ÙŠØ¨Ù‹Ø§ Ù„Ùˆ Ù…Ø§ ÙƒÙ†Øª ØªØ´ÙÙ‘Ø± ÙˆØªØ­Ø°Ù Ø¨Ø¹Ø¯ ÙƒÙ„ batch.

Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø£ÙØ¶Ù„:

framesPerPart = fps * 3 Ø£Ùˆ fps * 4 Ø£Ùˆ fps * 5

2) canvas.toDataURL('image/png', 0.9) ØºÙŠØ± Ù…ÙÙŠØ¯

quality Ù„Ø§ ÙŠØ¹Ù…Ù„ Ù…Ø¹ PNG.

3) html2canvas Ù†ÙØ³Ù‡ ÙŠØ³ØªÙ‡Ù„Ùƒ Ø°Ø§ÙƒØ±Ø©

Ø¨Ø¹Ø¯ ctx.drawImage(captureCanvas, ...) Ø­Ø§ÙˆÙ„ ØªØªØ±Ùƒ captureCanvas ÙŠØ±ÙˆØ­ Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ù…Ø±Ø§Ø¬Ø¹ØŒ ÙˆÙ„Ø§ ØªØ®Ø²Ù†Ù‡ ÙÙŠ arrays.

E) Ø¥Ø°Ø§ ØªØ¨ØºÙ‰ â€œØ£Ù‚ÙˆÙ‰ Ù†Ø³Ø®Ø©â€ Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ù†Ù‡Ø¬: JPG Ù„Ù„Ø¥Ø·Ø§Ø±Ø§Øª (MP4 ÙÙ‚Ø·)

Ù„Ùˆ output MP4 ÙÙ‚Ø·ØŒ Ù‡Ø°Ø§ ÙŠÙ‚Ù„Ù„ FS RAM ÙƒØ«ÙŠØ±:

canvas.toBlob(res, 'image/jpeg', 0.85)

ØºÙŠÙ‘Ø± input Ø¥Ù„Ù‰ frame_%05d.jpg

Ø¨Ø³ Ø£Ø¨Ù‚ÙŠØª Ù„Ùƒ PNG Ù„Ø£Ù†Ùƒ Ø°ÙƒØ±Øª MP4 Ø£Ùˆ GIF.

F) Ø£ÙŠÙ† Ø³ØªØ®ØªÙÙŠ Ø§Ù„Ù€ OOM Ø¨Ø§Ù„Ø¶Ø¨Ø·ØŸ

Ø­Ø°Ù Base64 ÙŠØ²ÙŠÙ„ 2â€“3 Ù†Ø³Ø® Ù„ÙƒÙ„ Ø¥Ø·Ø§Ø±

Ø¹Ø¯Ù… ØªØ®Ø²ÙŠÙ† batchFrames ÙŠÙ…Ù†Ø¹ ØªØ¶Ø®Ù… heap

encoding + Ø­Ø°Ù Ø¨Ø¹Ø¯ ÙƒÙ„ part ÙŠÙ…Ù†Ø¹ ØªÙƒØ¯Ù‘Ø³ PNG Ø¯Ø§Ø®Ù„ FS

concat ÙŠØ¬Ù…Ø¹ Ø¨Ø¯ÙˆÙ† Ø¥Ø¹Ø§Ø¯Ø© ØªØ±Ù…ÙŠØ² (Ø®ÙÙŠÙ)